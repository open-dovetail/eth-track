// Code generated by ethgo/abigen. DO NOT EDIT.
// Hash: 62e136008ed68ea54af71c8692df75a0046f82e2fcdc8410b6bf1bd3bf81a255
// Version: 0.1.1
package erc777

import (
	"fmt"
	"math/big"

	"github.com/umbracle/ethgo"
	"github.com/umbracle/ethgo/contract"
	"github.com/umbracle/ethgo/jsonrpc"
)

var (
	_ = big.NewInt
	_ = jsonrpc.NewClient
)

// ERC777 is a solidity contract
type ERC777 struct {
	c *contract.Contract
}

// NewERC777 creates a new instance of the contract at a specific address
func NewERC777(addr ethgo.Address, opts ...contract.ContractOption) *ERC777 {
	return &ERC777{c: contract.NewContract(addr, abiERC777, opts...)}
}

// calls

// Allowance calls the allowance method in the solidity contract
func (e *ERC777) Allowance(holder ethgo.Address, spender ethgo.Address, block ...ethgo.BlockNumber) (retval0 *big.Int, err error) {
	var out map[string]interface{}
	var ok bool

	out, err = e.c.Call("allowance", ethgo.EncodeBlock(block...), holder, spender)
	if err != nil {
		return
	}

	// decode outputs
	retval0, ok = out["0"].(*big.Int)
	if !ok {
		err = fmt.Errorf("failed to encode output at index 0")
		return
	}
	
	return
}

// BalanceOf calls the balanceOf method in the solidity contract
func (e *ERC777) BalanceOf(tokenHolder ethgo.Address, block ...ethgo.BlockNumber) (retval0 *big.Int, err error) {
	var out map[string]interface{}
	var ok bool

	out, err = e.c.Call("balanceOf", ethgo.EncodeBlock(block...), tokenHolder)
	if err != nil {
		return
	}

	// decode outputs
	retval0, ok = out["0"].(*big.Int)
	if !ok {
		err = fmt.Errorf("failed to encode output at index 0")
		return
	}
	
	return
}

// Decimals calls the decimals method in the solidity contract
func (e *ERC777) Decimals(block ...ethgo.BlockNumber) (retval0 uint8, err error) {
	var out map[string]interface{}
	var ok bool

	out, err = e.c.Call("decimals", ethgo.EncodeBlock(block...))
	if err != nil {
		return
	}

	// decode outputs
	retval0, ok = out["0"].(uint8)
	if !ok {
		err = fmt.Errorf("failed to encode output at index 0")
		return
	}
	
	return
}

// DefaultOperators calls the defaultOperators method in the solidity contract
func (e *ERC777) DefaultOperators(block ...ethgo.BlockNumber) (retval0 []ethgo.Address, err error) {
	var out map[string]interface{}
	var ok bool

	out, err = e.c.Call("defaultOperators", ethgo.EncodeBlock(block...))
	if err != nil {
		return
	}

	// decode outputs
	retval0, ok = out["0"].([]ethgo.Address)
	if !ok {
		err = fmt.Errorf("failed to encode output at index 0")
		return
	}
	
	return
}

// Granularity calls the granularity method in the solidity contract
func (e *ERC777) Granularity(block ...ethgo.BlockNumber) (retval0 *big.Int, err error) {
	var out map[string]interface{}
	var ok bool

	out, err = e.c.Call("granularity", ethgo.EncodeBlock(block...))
	if err != nil {
		return
	}

	// decode outputs
	retval0, ok = out["0"].(*big.Int)
	if !ok {
		err = fmt.Errorf("failed to encode output at index 0")
		return
	}
	
	return
}

// IsOperatorFor calls the isOperatorFor method in the solidity contract
func (e *ERC777) IsOperatorFor(operator ethgo.Address, tokenHolder ethgo.Address, block ...ethgo.BlockNumber) (retval0 bool, err error) {
	var out map[string]interface{}
	var ok bool

	out, err = e.c.Call("isOperatorFor", ethgo.EncodeBlock(block...), operator, tokenHolder)
	if err != nil {
		return
	}

	// decode outputs
	retval0, ok = out["0"].(bool)
	if !ok {
		err = fmt.Errorf("failed to encode output at index 0")
		return
	}
	
	return
}

// Name calls the name method in the solidity contract
func (e *ERC777) Name(block ...ethgo.BlockNumber) (retval0 string, err error) {
	var out map[string]interface{}
	var ok bool

	out, err = e.c.Call("name", ethgo.EncodeBlock(block...))
	if err != nil {
		return
	}

	// decode outputs
	retval0, ok = out["0"].(string)
	if !ok {
		err = fmt.Errorf("failed to encode output at index 0")
		return
	}
	
	return
}

// Symbol calls the symbol method in the solidity contract
func (e *ERC777) Symbol(block ...ethgo.BlockNumber) (retval0 string, err error) {
	var out map[string]interface{}
	var ok bool

	out, err = e.c.Call("symbol", ethgo.EncodeBlock(block...))
	if err != nil {
		return
	}

	// decode outputs
	retval0, ok = out["0"].(string)
	if !ok {
		err = fmt.Errorf("failed to encode output at index 0")
		return
	}
	
	return
}

// TotalSupply calls the totalSupply method in the solidity contract
func (e *ERC777) TotalSupply(block ...ethgo.BlockNumber) (retval0 *big.Int, err error) {
	var out map[string]interface{}
	var ok bool

	out, err = e.c.Call("totalSupply", ethgo.EncodeBlock(block...))
	if err != nil {
		return
	}

	// decode outputs
	retval0, ok = out["0"].(*big.Int)
	if !ok {
		err = fmt.Errorf("failed to encode output at index 0")
		return
	}
	
	return
}

// txns

// Approve sends a approve transaction in the solidity contract
func (e *ERC777) Approve(spender ethgo.Address, value *big.Int) (contract.Txn, error) {
	return e.c.Txn("approve", spender, value)
}

// AuthorizeOperator sends a authorizeOperator transaction in the solidity contract
func (e *ERC777) AuthorizeOperator(operator ethgo.Address) (contract.Txn, error) {
	return e.c.Txn("authorizeOperator", operator)
}

// Burn sends a burn transaction in the solidity contract
func (e *ERC777) Burn(amount *big.Int, data []byte) (contract.Txn, error) {
	return e.c.Txn("burn", amount, data)
}

// OperatorBurn sends a operatorBurn transaction in the solidity contract
func (e *ERC777) OperatorBurn(account ethgo.Address, amount *big.Int, data []byte, operatorData []byte) (contract.Txn, error) {
	return e.c.Txn("operatorBurn", account, amount, data, operatorData)
}

// OperatorSend sends a operatorSend transaction in the solidity contract
func (e *ERC777) OperatorSend(sender ethgo.Address, recipient ethgo.Address, amount *big.Int, data []byte, operatorData []byte) (contract.Txn, error) {
	return e.c.Txn("operatorSend", sender, recipient, amount, data, operatorData)
}

// RevokeOperator sends a revokeOperator transaction in the solidity contract
func (e *ERC777) RevokeOperator(operator ethgo.Address) (contract.Txn, error) {
	return e.c.Txn("revokeOperator", operator)
}

// Send sends a send transaction in the solidity contract
func (e *ERC777) Send(recipient ethgo.Address, amount *big.Int, data []byte) (contract.Txn, error) {
	return e.c.Txn("send", recipient, amount, data)
}

// Transfer sends a transfer transaction in the solidity contract
func (e *ERC777) Transfer(recipient ethgo.Address, amount *big.Int) (contract.Txn, error) {
	return e.c.Txn("transfer", recipient, amount)
}

// TransferFrom sends a transferFrom transaction in the solidity contract
func (e *ERC777) TransferFrom(holder ethgo.Address, recipient ethgo.Address, amount *big.Int) (contract.Txn, error) {
	return e.c.Txn("transferFrom", holder, recipient, amount)
}

// events

func (e *ERC777) ApprovalEventSig() ethgo.Hash {
	return e.c.GetABI().Events["Approval"].ID()
}

func (e *ERC777) AuthorizedOperatorEventSig() ethgo.Hash {
	return e.c.GetABI().Events["AuthorizedOperator"].ID()
}

func (e *ERC777) BurnedEventSig() ethgo.Hash {
	return e.c.GetABI().Events["Burned"].ID()
}

func (e *ERC777) MintedEventSig() ethgo.Hash {
	return e.c.GetABI().Events["Minted"].ID()
}

func (e *ERC777) RevokedOperatorEventSig() ethgo.Hash {
	return e.c.GetABI().Events["RevokedOperator"].ID()
}

func (e *ERC777) SentEventSig() ethgo.Hash {
	return e.c.GetABI().Events["Sent"].ID()
}

func (e *ERC777) TransferEventSig() ethgo.Hash {
	return e.c.GetABI().Events["Transfer"].ID()
}
