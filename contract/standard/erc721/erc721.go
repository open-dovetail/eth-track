// Code generated by go-web3/abigen. DO NOT EDIT.
// Hash: f173be9cb8462f7791e4b4b43cc0e3a1adb21977427d29b06bd60b0648e9dfb2
package erc721

import (
	"fmt"
	"math/big"

	web3 "github.com/umbracle/go-web3"
	"github.com/umbracle/go-web3/contract"
	"github.com/umbracle/go-web3/jsonrpc"
)

var (
	_ = big.NewInt
)

// ERC721 is a solidity contract
type ERC721 struct {
	c *contract.Contract
}

// NewERC721 creates a new instance of the contract at a specific address
func NewERC721(addr web3.Address, provider *jsonrpc.Client) *ERC721 {
	return &ERC721{c: contract.NewContract(addr, abiERC721, provider)}
}

// Contract returns the contract object
func (e *ERC721) Contract() *contract.Contract {
	return e.c
}

// calls

// BalanceOf calls the balanceOf method in the solidity contract
func (e *ERC721) BalanceOf(owner web3.Address, block ...web3.BlockNumber) (retval0 *big.Int, err error) {
	var out map[string]interface{}
	var ok bool

	out, err = e.c.Call("balanceOf", web3.EncodeBlock(block...), owner)
	if err != nil {
		return
	}

	// decode outputs
	retval0, ok = out["0"].(*big.Int)
	if !ok {
		err = fmt.Errorf("failed to encode output at index 0")
		return
	}
	
	return
}

// GetApproved calls the getApproved method in the solidity contract
func (e *ERC721) GetApproved(tokenId *big.Int, block ...web3.BlockNumber) (retval0 web3.Address, err error) {
	var out map[string]interface{}
	var ok bool

	out, err = e.c.Call("getApproved", web3.EncodeBlock(block...), tokenId)
	if err != nil {
		return
	}

	// decode outputs
	retval0, ok = out["0"].(web3.Address)
	if !ok {
		err = fmt.Errorf("failed to encode output at index 0")
		return
	}
	
	return
}

// IsApprovedForAll calls the isApprovedForAll method in the solidity contract
func (e *ERC721) IsApprovedForAll(owner web3.Address, operator web3.Address, block ...web3.BlockNumber) (retval0 bool, err error) {
	var out map[string]interface{}
	var ok bool

	out, err = e.c.Call("isApprovedForAll", web3.EncodeBlock(block...), owner, operator)
	if err != nil {
		return
	}

	// decode outputs
	retval0, ok = out["0"].(bool)
	if !ok {
		err = fmt.Errorf("failed to encode output at index 0")
		return
	}
	
	return
}

// Name calls the name method in the solidity contract
func (e *ERC721) Name(block ...web3.BlockNumber) (retval0 string, err error) {
	var out map[string]interface{}
	var ok bool

	out, err = e.c.Call("name", web3.EncodeBlock(block...))
	if err != nil {
		return
	}

	// decode outputs
	retval0, ok = out["0"].(string)
	if !ok {
		err = fmt.Errorf("failed to encode output at index 0")
		return
	}
	
	return
}

// OwnerOf calls the ownerOf method in the solidity contract
func (e *ERC721) OwnerOf(tokenId *big.Int, block ...web3.BlockNumber) (retval0 web3.Address, err error) {
	var out map[string]interface{}
	var ok bool

	out, err = e.c.Call("ownerOf", web3.EncodeBlock(block...), tokenId)
	if err != nil {
		return
	}

	// decode outputs
	retval0, ok = out["0"].(web3.Address)
	if !ok {
		err = fmt.Errorf("failed to encode output at index 0")
		return
	}
	
	return
}

// SupportsInterface calls the supportsInterface method in the solidity contract
func (e *ERC721) SupportsInterface(interfaceId [4]byte, block ...web3.BlockNumber) (retval0 bool, err error) {
	var out map[string]interface{}
	var ok bool

	out, err = e.c.Call("supportsInterface", web3.EncodeBlock(block...), interfaceId)
	if err != nil {
		return
	}

	// decode outputs
	retval0, ok = out["0"].(bool)
	if !ok {
		err = fmt.Errorf("failed to encode output at index 0")
		return
	}
	
	return
}

// Symbol calls the symbol method in the solidity contract
func (e *ERC721) Symbol(block ...web3.BlockNumber) (retval0 string, err error) {
	var out map[string]interface{}
	var ok bool

	out, err = e.c.Call("symbol", web3.EncodeBlock(block...))
	if err != nil {
		return
	}

	// decode outputs
	retval0, ok = out["0"].(string)
	if !ok {
		err = fmt.Errorf("failed to encode output at index 0")
		return
	}
	
	return
}

// TokenURI calls the tokenURI method in the solidity contract
func (e *ERC721) TokenURI(tokenId *big.Int, block ...web3.BlockNumber) (retval0 string, err error) {
	var out map[string]interface{}
	var ok bool

	out, err = e.c.Call("tokenURI", web3.EncodeBlock(block...), tokenId)
	if err != nil {
		return
	}

	// decode outputs
	retval0, ok = out["0"].(string)
	if !ok {
		err = fmt.Errorf("failed to encode output at index 0")
		return
	}
	
	return
}

// txns

// Approve sends a approve transaction in the solidity contract
func (e *ERC721) Approve(to web3.Address, tokenId *big.Int) *contract.Txn {
	return e.c.Txn("approve", to, tokenId)
}

// SafeTransferFrom sends a safeTransferFrom transaction in the solidity contract
func (e *ERC721) SafeTransferFrom(from web3.Address, to web3.Address, tokenId *big.Int, data []byte) *contract.Txn {
	return e.c.Txn("safeTransferFrom", from, to, tokenId, data)
}

// SetApprovalForAll sends a setApprovalForAll transaction in the solidity contract
func (e *ERC721) SetApprovalForAll(operator web3.Address, approved bool) *contract.Txn {
	return e.c.Txn("setApprovalForAll", operator, approved)
}

// TransferFrom sends a transferFrom transaction in the solidity contract
func (e *ERC721) TransferFrom(from web3.Address, to web3.Address, tokenId *big.Int) *contract.Txn {
	return e.c.Txn("transferFrom", from, to, tokenId)
}

// events

func (e *ERC721) ApprovalEventSig() web3.Hash {
	return e.c.ABI().Events["Approval"].ID()
}

func (e *ERC721) ApprovalForAllEventSig() web3.Hash {
	return e.c.ABI().Events["ApprovalForAll"].ID()
}

func (e *ERC721) TransferEventSig() web3.Hash {
	return e.c.ABI().Events["Transfer"].ID()
}
